// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, eaddress, euint32, externalEaddress, externalEuint32, ebool} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

/// @title ZSecureDatabase
/// @notice Confidential database registry that stores encrypted access addresses and data entries
/// @dev All encrypted values leverage Zama's FHE primitives. The contract never handles plaintext secrets.
contract ZSecureDatabase is ZamaEthereumConfig {
    struct EncryptedEntry {
        euint32 cipher;
        uint256 timestamp;
        address submittedBy;
    }

    struct SecureDatabase {
        string name;
        address owner;
        eaddress encryptedAccessPoint;
        uint256 createdAt;
        uint256 updatedAt;
        EncryptedEntry[] entries;
    }

    error DatabaseNotFound(uint256 databaseId);
    error NotDatabaseOwner(address caller, uint256 databaseId);
    error InvalidName();
    error InvalidAccount(address account);
    error EntryOutOfBounds(uint256 databaseId, uint256 entryIndex);

    event DatabaseCreated(uint256 indexed databaseId, address indexed owner, string name);
    event DatabaseAddressShared(uint256 indexed databaseId, address indexed account);
    event DatabaseEntryStored(uint256 indexed databaseId, uint256 indexed entryIndex, address indexed submitter);
    event DatabaseEntryShared(uint256 indexed databaseId, uint256 indexed entryIndex, address indexed account);

    uint256 private _nextDatabaseId = 1;
    mapping(uint256 => SecureDatabase) private _databases;
    mapping(address => uint256[]) private _databaseIdsByOwner;

    /// @notice Creates a new encrypted database entry.
    /// @param name Human readable database name.
    /// @param encryptedAddress Cipher handle that stores the randomly generated address A.
    /// @param inputProof Proof generated by the relayer during encryption.
    /// @return databaseId Newly created database identifier.
    function createDatabase(
        string calldata name,
        externalEaddress encryptedAddress,
        bytes calldata inputProof
    ) external returns (uint256 databaseId) {
        if (bytes(name).length == 0) {
            revert InvalidName();
        }

        eaddress securedAddress = FHE.fromExternal(encryptedAddress, inputProof);
        databaseId = _nextDatabaseId++;

        SecureDatabase storage database = _databases[databaseId];
        database.name = name;
        database.owner = msg.sender;
        database.encryptedAccessPoint = securedAddress;
        database.createdAt = block.timestamp;
        database.updatedAt = block.timestamp;

        _databaseIdsByOwner[msg.sender].push(databaseId);

        FHE.allowThis(securedAddress);
        FHE.allow(securedAddress, msg.sender);

        emit DatabaseCreated(databaseId, msg.sender, name);
        emit DatabaseAddressShared(databaseId, msg.sender);
    }

    /// @notice Stores an encrypted value inside a database.
    /// @param databaseId Target database identifier.
    /// @param encryptedValue Cipher handle produced by encrypting the clear number with address A.
    /// @param encryptedAccessPoint Cipher handle that must match the database access address A.
    /// @param inputProof Proof generated by the relayer during encryption.
    function storeEncryptedValue(
        uint256 databaseId,
        externalEuint32 encryptedValue,
        externalEaddress encryptedAccessPoint,
        bytes calldata inputProof
    ) external onlyDatabaseOwner(databaseId) {
        SecureDatabase storage database = _databases[databaseId];
        euint32 cipher = FHE.fromExternal(encryptedValue, inputProof);
        eaddress providedAccessPoint = FHE.fromExternal(encryptedAccessPoint, inputProof);
        ebool isAuthorized = FHE.eq(providedAccessPoint, database.encryptedAccessPoint);
        cipher = FHE.select(isAuthorized, cipher, FHE.asEuint32(0));

        database.entries.push();
        uint256 entryIndex = database.entries.length - 1;
        EncryptedEntry storage entry = database.entries[entryIndex];
        entry.cipher = cipher;
        entry.timestamp = block.timestamp;
        entry.submittedBy = msg.sender;

        database.updatedAt = block.timestamp;

        FHE.allowThis(cipher);
        FHE.allow(cipher, database.owner);

        emit DatabaseEntryStored(databaseId, entryIndex, msg.sender);
    }

    /// @notice Re-grants ACL permissions to decrypt the stored access address.
    /// @dev Useful when a user reconnects with a fresh wallet session.
    function refreshAddressAccess(uint256 databaseId, address account) external onlyDatabaseOwner(databaseId) {
        if (account == address(0)) {
            revert InvalidAccount(account);
        }

        SecureDatabase storage database = _databases[databaseId];
        FHE.allow(database.encryptedAccessPoint, account);
        emit DatabaseAddressShared(databaseId, account);
    }

    /// @notice Shares a stored value with another account.
    function shareEncryptedValue(uint256 databaseId, uint256 entryIndex, address account) external onlyDatabaseOwner(databaseId) {
        if (account == address(0)) {
            revert InvalidAccount(account);
        }

        SecureDatabase storage database = _databases[databaseId];
        if (entryIndex >= database.entries.length) {
            revert EntryOutOfBounds(databaseId, entryIndex);
        }

        EncryptedEntry storage entry = database.entries[entryIndex];
        FHE.allow(entry.cipher, account);
        emit DatabaseEntryShared(databaseId, entryIndex, account);
    }

    /// @notice Returns metadata for a database.
    function getDatabaseMetadata(uint256 databaseId)
        external
        view
        returns (string memory name, address owner, uint256 createdAt, uint256 updatedAt, uint256 valueCount)
    {
        SecureDatabase storage database = _databases[databaseId];
        if (database.owner == address(0)) {
            revert DatabaseNotFound(databaseId);
        }

        name = database.name;
        owner = database.owner;
        createdAt = database.createdAt;
        updatedAt = database.updatedAt;
        valueCount = database.entries.length;
    }

    /// @notice Returns the encrypted address handle for a database.
    function getEncryptedDatabaseAddress(uint256 databaseId) external view returns (eaddress) {
        SecureDatabase storage database = _databases[databaseId];
        if (database.owner == address(0)) {
            revert DatabaseNotFound(databaseId);
        }

        return database.encryptedAccessPoint;
    }

    /// @notice Returns the encrypted value stored at a specific index.
    function getEncryptedValue(uint256 databaseId, uint256 entryIndex) external view returns (EncryptedEntry memory) {
        SecureDatabase storage database = _databases[databaseId];
        if (database.owner == address(0)) {
            revert DatabaseNotFound(databaseId);
        }
        if (entryIndex >= database.entries.length) {
            revert EntryOutOfBounds(databaseId, entryIndex);
        }

        return database.entries[entryIndex];
    }

    /// @notice Lists the database ids that belong to an owner.
    function getOwnerDatabases(address owner) external view returns (uint256[] memory) {
        return _databaseIdsByOwner[owner];
    }

    /// @notice Exposes the identifier that will be assigned to the next database.
    function nextDatabaseId() external view returns (uint256) {
        return _nextDatabaseId;
    }

    modifier onlyDatabaseOwner(uint256 databaseId) {
        SecureDatabase storage database = _databases[databaseId];
        if (database.owner == address(0)) {
            revert DatabaseNotFound(databaseId);
        }
        if (database.owner != msg.sender) {
            revert NotDatabaseOwner(msg.sender, databaseId);
        }
        _;
    }
}
